# GIS局放在线监测系统 Demo

这是一个用于演示GIS（气体绝缘开关设备）局部放电在线监测系统的前端Demo。它模拟了GIS设备的实时运行状态、局部放电数据，并提供了直观的图表展示和动态更新功能。

## 主要功能

*   **实时数据概览 (Dashboard)**：显示设备总数、在线设备数、异常设备数，以及平均局放趋势图。
*   **设备列表**：展示所有GIS设备的概况，并可点击查看详细信息。
*   **设备详情页**：
    *   显示设备基本信息和辅助参数（温度、湿度、SF6气体压力）。
    *   **局放幅值趋势图**：实时动态展示局放幅值随时间的变化。
    *   **PRPD 图谱**：相位分辨局部放电图谱，用于分析局放类型。
    *   **PRPS 三维图**：相位分辨脉冲序列三维图，提供更全面的局放特征信息（X轴：相位，Y轴：周期，Z轴：脉冲次数）。
    *   **频谱图**：展示局放信号的频率分布。
    *   **历史告警记录**：显示设备的告警历史。
    *   **诊断分析结果**：模拟给出设备的诊断结论和风险评估，**并显示预测的局放类型和置信度**。
*   **实时数据更新**：数据每隔3秒从后端API获取并更新，趋势图平滑滚动，设备状态和局放模式可能动态变化。
*   **局放类型智能识别**：后端集成基于SVM的机器学习算法，根据PRPD数据自动识别局放类型。

## 技术栈

*   **前端**：HTML, CSS, JavaScript
*   **后端**：Python FastAPI (使用 `data.json` 模拟数据库)
*   **局放识别算法**：Python (SVM, scikit-learn, OpenCV, joblib)
*   **图表库**：
    *   [Chart.js](https://www.chartjs.org/) (用于趋势图和PRPD图)
    *   [Plotly.js](https://plotly.com/javascript/) (用于PRPS三维图和频谱图)

## 数据流

当前Demo的数据流如下：

1.  **前端 (HTML/CSS/JavaScript)**：
    *   前端页面 (`index.html` 中的 `script.js`) 通过 JavaScript 的 `fetch` API 向后端 FastAPI 服务发送 HTTP 请求。
    *   请求的API地址为 `http://127.0.0.1:5000/api/devices` (获取所有设备数据) 或 `http://127.0.0.1:5000/api/devices/{device_id}` (获取特定设备详情)。
    *   前端接收到后端返回的 JSON 数据后，更新页面上的Dashboard、设备列表和各种图表。

2.  **后端 (Python FastAPI)**：
    *   后端服务 (`backend/main.py`) 使用 FastAPI 框架。
    *   它的数据源是项目根目录下的 `backend/data.json` 文件，该文件存储了GIS设备的初始数据。
    *   **模拟实时更新**：每次前端请求数据时，后端都会对从 `data.json` 读取的数据进行实时的模拟更新（例如，随机波动局放值、温度等，并模拟局放趋势的滚动，甚至模拟设备状态的变化）。这意味着前端每次获取到的数据都是动态变化的，从而实现了Demo的实时动态效果。
    *   **局放类型识别**：后端在返回设备数据前，会根据模拟的PRPD数据（从 `pdTrend` 派生）调用集成的SVM模型进行局放类型预测，并将预测结果（类型和置信度）添加到设备数据中。

## 与实际系统的差距及未来展望

目前我们构建的Demo虽然功能相对完善，但与实际的GIS局放在线监测系统相比，仍然存在显著差距。这些差距主要体现在以下几个方面：

1.  **数据源与数据采集：**
    *   **Demo：** 数据来源于一个静态的 `data.json` 文件，并通过后端进行模拟的随机波动。
    *   **实际系统：** 数据直接来源于安装在GIS设备上的各种传感器（如特高频UHF传感器、超声波传感器、暂态地电压TEV传感器、SF6气体压力/温度传感器等）。这些传感器通过专用的数据采集单元（DAU）或边缘计算设备，以高采样率、高精度实时采集原始信号。数据量巨大且复杂。

2.  **数据传输与通信：**
    *   **Demo：** 前后端通过简单的HTTP请求（`fetch` API）进行数据传输。
    *   **实际系统：** 涉及工业级通信协议（如Modbus, IEC 61850, OPC UA等），数据传输通常通过光纤、工业以太网或无线网络进行，需要保证高可靠性、低延迟和数据完整性。

3.  **数据存储与管理：**
    *   **Demo：** 数据存储在简单的JSON文件中，每次请求都会重新模拟。
    *   **实际系统：** 采用高性能、高可靠性的数据库系统（如时序数据库InfluxDB、TDengine，关系型数据库PostgreSQL、MySQL，或NoSQL数据库MongoDB等），能够存储海量的历史数据，并支持高效的查询、归档和备份。

4.  **数据处理与分析：**
    *   **Demo：** 局放图谱（PRPD, PRPS, 频谱）的生成是基于简单的模拟数据和前端绘图库。诊断结果是硬编码或基于简单的阈值判断。
    *   **实际系统：**
        *   **信号预处理：** 原始信号需要进行复杂的滤波、去噪、基线校正等处理，以消除干扰。
        *   **特征提取：** 从处理后的信号中提取局放脉冲的幅值、相位、重复率、能量等特征参数。
        *   **模式识别与诊断：** 结合机器学习（ML）和人工智能（AI）算法（如神经网络、支持向量机、聚类分析等），对局放模式进行自动识别和分类（例如，区分尖端放电、内部空隙放电、悬浮电位放电、颗粒放电等），并给出更精确的诊断结论和发展趋势预测。
        *   **多源数据融合：** 结合局放数据、温度、湿度、SF6压力、负荷电流等多种数据进行综合分析，提供更全面的设备健康评估。

5.  **告警与预警机制：**
    *   **Demo：** 简单的阈值告警和模拟告警列表。
    *   **实际系统：** 具备多级告警机制（预警、告警、紧急告警），支持自定义告警规则、告警联动（如短信、邮件、声光报警）、告警确认与处理流程、告警历史追溯等。

6.  **系统架构与可扩展性：**
    *   **Demo：** 单体应用，前端和后端相对独立，没有考虑大规模部署。
    *   **实际系统：** 通常采用分布式、微服务架构，具备高可用性、负载均衡、容错机制。能够管理成百上千台GIS设备的监测数据，并支持多用户、多权限访问。

7.  **用户界面与交互 (UI/UX)：**
    *   **Demo：** 基础的网页布局和图表展示。
    *   **实际系统：** 拥有专业设计的用户界面，提供更丰富的交互功能（如数据筛选、时间轴选择、图表缩放/平移、自定义报表生成、设备地理信息系统GIS集成等），以满足不同角色的用户需求（运维人员、专家、管理人员）。

8.  **安全性：**
    *   **Demo：** 没有考虑任何安全措施。
    *   **实际系统：** 安全性是工业控制系统的重中之重。包括用户认证与授权、数据加密传输（HTTPS）、访问控制、日志审计、防DDoS攻击等，确保系统和数据的安全。

9.  **集成性：**
    *   **Demo：** 独立运行。
    *   **实际系统：** 通常需要与电力公司的其他系统（如SCADA系统、资产管理系统、故障诊断系统等）进行集成，实现数据共享和业务协同。

简而言之，我们的Demo是一个很好的概念验证和功能展示，但实际系统是一个复杂的、多学科交叉的工程项目，涉及传感器技术、通信技术、大数据处理、人工智能、工业控制和网络安全等多个领域。

## 深入理解

### 1. 局放识别算法的PRPD图输入

**疑问：** 是后端绘制的PRPD图发送给局放识别算法的吗？

**解答：** **不是。**

局放识别算法（SVM模型）需要的是PRPD的**数值表示**，而不是前端用户看到的**可视化图像**。这个数值表示通常是一个经过预处理的**特征向量**，它来源于PRPD的原始数据点（相位-幅值对）经过图像化处理后的像素值。

**数据流向：**

1.  **后端 (FastAPI)** 拥有PRPD的**原始数据点**（在Demo中是模拟生成的 `simulated_prpd_points`）。
2.  后端代码中的 `prpd_data_to_image()` 函数将这些原始数据点**转换成一个灰度图像的NumPy数组**（即一个数值矩阵，代表图像的像素强度）。
3.  这个NumPy数组（数值矩阵）经过展平、标准化和PCA降维等预处理后，形成一个**特征向量**。
4.  这个**特征向量**被输入到后端加载的SVM模型 (`clf.predict()`) 中进行预测。
5.  算法预测出局放类型和置信度后，后端将这些结果作为JSON数据的一部分发送给前端。
6.  **前端 (JavaScript)** 接收到后端提供的 `prpdType`（例如 'tip', 'void' 等），然后使用 `Chart.js` 库**绘制出可视化**的PRPD图，以图形方式展示该类型局放的典型模式。

简而言之，**算法所需的“图”是在后端生成的数值表示，而不是前端用户看到的视觉图表。** 前端只是根据后端给出的分类结果来“画”出相应的图表模式。

### 2. 多个GIS设备识别结果的并行性

**疑问：** 有5个GIS设备，它们之间的识别结果是并行的吗？

**解答：** **在当前的实现中，不是并行的，而是串行（顺序）处理的。**

*   在 `backend/main.py` 中的 `update_simulated_data` 函数，通过一个标准的Python `for` 循环 (`for device in devices_list:`) 遍历所有设备。
*   在循环内部，对于每个 `device`，它会调用 `predict_pd_type(simulated_prpd_points)` 函数。
*   Python的 `for` 循环是**同步且串行**执行的。这意味着，只有当前设备的 `predict_pd_type` 函数完全执行完毕并返回结果后，才会开始处理下一个设备的 `predict_pd_type`。

**原因分析：**

*   **简化实现：** 对于Demo而言，串行处理通常更简单，更容易理解和调试。
*   **FastAPI的异步特性与CPU密集型任务：** 尽管FastAPI本身是异步框架，但它主要体现在处理**I/O密集型**任务（如网络请求、数据库查询）时能够非阻塞。而像 `joblib.load`、`scaler.transform`、`pca.transform` 和 `clf.predict` 这样**CPU密集型**的机器学习计算，在Python中默认是阻塞的。即使在 `async` 函数中调用它们，它们仍然会阻塞事件循环，除非使用 `asyncio.to_thread()` 将它们放到单独的线程池中执行，或者使用 `multiprocessing` 模块进行真正的并行计算。

**实际系统中的并行化考虑：**

在实际的生产环境中，为了提高处理大量设备时的效率，通常会考虑并行化：

*   **多线程/多进程：** 在Python后端使用 `concurrent.futures` 模块（`ThreadPoolExecutor` 或 `ProcessPoolExecutor`）来并行处理每个设备的预测任务。
*   **异步非阻塞：** 如果预测函数本身是异步的（例如，调用一个远程的预测服务），FastAPI的 `async/await` 就能发挥作用，通过 `asyncio.gather` 并发地发送多个预测请求。
*   **消息队列：** 将预测任务放入消息队列（如RabbitMQ, Kafka），由多个工作进程/服务异步消费并处理。

## 如何查看 Demo

您可以直接通过 GitHub Pages 访问此 Demo：

[https://yangyuqing15715165798.github.io/gis-monitoring-demo/](https://yangyuqing15715165798.github.io/gis-monitoring-demo/)

## 本地运行

如果您想在本地运行此Demo，请按照以下步骤操作：

1.  **克隆仓库**：
    ```bash
    git clone https://github.com/yangyuqing15715165798/gis-monitoring-front-backend-svm.git
    ```
2.  **进入项目目录**：
    ```bash
    cd gis-monitoring-front-backend-svm
    ```
3.  **安装后端依赖** (如果尚未安装)：
    ```bash
    pip install fastapi uvicorn numpy opencv-python scikit-learn joblib
    ```
4.  **启动后端服务**：
    打开一个命令行窗口，进入 `backend` 目录，并运行：
    ```bash
    cd backend
    uvicorn main:app --reload --host 127.0.0.1 --port 5000
    ```
    后端服务将在 `http://127.0.0.1:5000` 运行。

5.  **启动前端HTTP服务器**：
    打开另一个命令行窗口，进入项目根目录 (即 `index.html` 所在的目录)，并运行：
    ```bash
    python -m http.server 8000
    ```
    前端服务将在 `http://localhost:8000` 运行。

6.  **在浏览器中访问 Demo**：
    在浏览器中打开 `http://localhost:8000/`。

## 贡献

欢迎提出建议或贡献！
